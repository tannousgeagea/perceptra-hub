from django.db import models
from projects.models import (
    Project,
    ProjectImage
)

class AnnotationGroup(models.Model):
    project = models.ForeignKey(
        Project, on_delete=models.CASCADE, related_name='annotation_groups'
    )
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'annotation_group'
        verbose_name_plural = "Annotation Groups"

    def __str__(self):
        return f"{self.name} - {self.project.name}"


class AnnotationClass(models.Model):
    annotation_group = models.ForeignKey(
        AnnotationGroup, on_delete=models.CASCADE, related_name='classes'
    )
    class_id = models.PositiveIntegerField()
    name = models.CharField(max_length=255) 
    color = models.CharField(max_length=7, null=True, blank=True)
    description = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'annotation_class'
        verbose_name_plural = 'Annotation Classes'
        unique_together = ('annotation_group', 'class_id')

    def __str__(self):
        return f"{self.class_id} - {self.name} ({self.annotation_group.project})"


# Create your models here.
class AnnotationType(models.Model):
    name = models.CharField(max_length=50, unique=True)  # e.g., "Bounding Box", "Polygon"
    description = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'annotation_type'
        verbose_name_plural = 'Annotation Types'

    def __str__(self):
        return self.name
    
class Annotation(models.Model):
    project_image = models.ForeignKey(
        ProjectImage, on_delete=models.CASCADE, related_name='annotations'
    )
    annotation_type = models.ForeignKey(
        AnnotationType, on_delete=models.SET_NULL, null=True, related_name='annotations'
    )
    annotation_class = models.ForeignKey(
        AnnotationClass, on_delete=models.CASCADE, related_name='annotations'
    )
    data = models.JSONField()
    annotation_uid = models.CharField(max_length=100, unique=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.CharField(max_length=255, blank=True, null=True)
    reviewed = models.BooleanField(default=False)
    rating = models.ForeignKey(AnnotationClass, on_delete=models.SET_NULL, null=True, blank=True)
    feedback_provided = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)

    ANNOTATION_SOURCE_CHOICES = [
        ('manual', 'Manual Annotation'),
        ('prediction', 'Model Prediction'),
    ]
    annotation_source = models.CharField(
        max_length=20,
        choices=ANNOTATION_SOURCE_CHOICES,
        default='manual',
        help_text="Indicates whether the annotation was created manually or generated by a model."
    )

    confidence = models.FloatField(
        null=True,
        blank=True,
        help_text="Prediction confidence (only applicable if source is 'prediction')"
    )

    class Meta:
        db_table = 'annotation'
        verbose_name_plural = 'Annotations'

    def __str__(self):
        return f"{self.project_image.project.name} - {self.annotation_class.name}"
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._original_data = self.data.copy() if self.data else None
        self._original_class_id = self.annotation_class_id

    def save(self, *args, **kwargs):
        # Ensure self.data exists, is a list, and contains exactly 4 coordinates: [xmin, ymin, xmax, ymax]
        if self.data and isinstance(self.data, list) and len(self.data) == 4:
            # Clip each coordinate to the [0, 1] range.
            self.data = [max(0, min(1, coord)) for coord in self.data]
        super().save(*args, **kwargs)

        if self.annotation_source == 'prediction':
            if not self.is_active:
                status = 'FP'
            elif self.annotation_class_id != self._original_class_id or self.data != self._original_data:
                status = 'FP'
            else:
                status = 'TP'

            AnnotationAudit.objects.update_or_create(
                annotation=self,
                defaults={
                    "evaluation_status": status,
                    "was_edited": status == 'FP',
                }
            )
        elif self.annotation_source == 'manual':
            AnnotationAudit.objects.update_or_create(
                annotation=self,
                defaults={
                    "evaluation_status": "FN",
                    "was_edited": False,
                }
            )

class AnnotationAudit(models.Model):
    annotation = models.OneToOneField(
        Annotation,
        on_delete=models.CASCADE,
        related_name="audit"
    )
    evaluation_status = models.CharField(
        max_length=2,
        choices=[
            ('TP', 'True Positive'),
            ('FP', 'False Positive'),
            ('FN', 'False Negative'),
        ],
        null=True,
        blank=True
    )
    was_edited = models.BooleanField(default=False)
    matched_manual_annotation = models.ForeignKey(
        "Annotation",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="matched_predictions"
    )
    iou = models.FloatField(null=True, blank=True)
    reviewed_at = models.DateTimeField(auto_now=True)
    reviewed_by = models.CharField(max_length=255, blank=True, null=True)  # Or use ForeignKey to User

    class Meta:
        db_table = 'annotation_audit'
        verbose_name_plural = "Annotation Audits"

    def __str__(self):
        return f"{self.annotation.id} - {self.evaluation_status or 'Unreviewed'}"
